<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8">
    <title>ICLR Points — Per-Conference View</title>
    <link rel="stylesheet" href="https://zhtluo.com/style.css" type="text/css" />
    <style>
        /* Flex container for the overall layout */
        #layout {
            display: flex;
            flex-direction: row;
        }

        #sidebar {
            overflow-y: auto;
            padding: 20px;
            border-right: 1px solid #ccc;
            box-sizing: border-box;
            width: 300px;
        }

        #canvas {
            padding: 20px;
            overflow-y: auto;
            box-sizing: border-box;
            width: 500px;
        }

        @media (max-width: 800px) {
            #layout {
                flex-direction: column-reverse;
            }

            #sidebar {
                width: 100%;
            }

            #canvas {
                width: 100%;
            }
        }

        /* Styling for selectors and checkboxes */
        #date-range {
            margin-bottom: 20px;
        }

        #date-range label {
            margin-right: 5px;
        }

        #date-range select {
            margin-right: 15px;
        }

        .area-container,
        .conference-container {
            margin-left: 20px;
        }

        .separator {
            margin-top: 5px;
            margin-bottom: 5px;
            border-top: 1px dashed #ccc;
        }

        #view-toggle {
            margin-bottom: 10px;
        }

        #view-toggle label {
            margin-right: 15px;
        }

        .description {
            max-width: 800px;
            line-height: 1.5;
        }

        .description h2 {
            margin-top: 1.5em;
        }

        .formula {
            background: #f5f5f5;
            border-left: 3px solid #ccc;
            padding: 10px 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.95em;
            overflow-x: auto;
        }

        details {
            margin: 10px 0;
        }

        details summary {
            cursor: pointer;
            font-weight: bold;
        }

        footer {
            margin-top: 40px;
            padding: 15px 0;
            border-top: 1px solid #eee;
            font-size: 0.75em;
            color: #999;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.0.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
</head>

<body>
    <h1>ICLR Points — Per-Conference View</h1>

    <div class="description">
        <p>
            This is a fork of <a href="https://iclrpoints.com/">iclrpoints.com</a> with two changes:
        </p>
        <ol>
            <li><strong>Per-conference granularity:</strong> you can view ICLR points for individual conferences (e.g., POPL and PLDI separately) instead of only at the area level (e.g., "Programming Languages").</li>
            <li><strong>Paper-count-based splitting:</strong> faculty effort is split proportionally to their number of papers at each conference, rather than equally across distinct areas.</li>
        </ol>
        <p>You can also toggle individual conferences on/off. The baseline is always the ICLR conference itself (which always shows 1.00 ICLR points).</p>

        <details>
            <summary>Formula details</summary>
            <p>For each faculty member <em>f</em> who publishes at selected conferences:</p>
            <div class="formula">
                contribution(f, c) = papers(f, c) / total_papers(f)
            </div>
            <p>where <code>papers(f, c)</code> is the number of papers faculty <em>f</em> has at conference <em>c</em>,
               and <code>total_papers(f)</code> is their total across all conferences in the dataset (not just selected ones, so per-conference values are stable).</p>
            <p><strong>Example:</strong> A faculty with 1 PLDI paper, 1 POPL paper, and 2 ICLR papers (4 total) contributes
               0.25 to PLDI, 0.25 to POPL, and 0.50 to ICLR.</p>
            <p>The effective faculty count and effort per paper for each conference:</p>
            <div class="formula">
                confEffective(c) = &Sigma;<sub>f</sub> contribution(f, c)<br>
                effort(c) = confEffective(c) &times; years / pubCount(c)
            </div>
            <p>Finally, everything is normalized to ICLR:</p>
            <div class="formula">
                iclrPoints(c) = effort(c) / effort(ICLR)
            </div>
            <p>The <strong>area-level</strong> view aggregates conference-level effective faculties and publications
               to the area level before computing effort. Note that area-level values will differ from the
               <a href="https://iclrpoints.com/">original site</a> because the splitting formula changed
               (paper-count-based instead of distinct-area-based).</p>
        </details>
    </div>

    <div id="layout">
        <!-- Sidebar for selectors -->
        <div id="sidebar">
            <!-- Date Range Selector -->
            <div id="date-range">
                <label for="from-date">From Date:</label>
                <select id="from-date"></select>
                <br />
                <label for="to-date">To Date:</label>
                <select id="to-date"></select>
            </div>
            <!-- Conference Checkboxes -->
            <div id="checkboxes"></div>
        </div>

        <!-- Canvas for results -->
        <div id="canvas">
            <div id="results">
                <p>Downloading data, please wait...</p>
            </div>
            <div id="view-toggle">
                <label><input type="radio" name="view" value="area" checked> Area view</label>
                <label><input type="radio" name="view" value="conference"> Conference view</label>
            </div>
            <canvas id="iclrChart" height="400">
            </canvas>
        </div>
    </div>

    <script>
        // Global variables to store CSV data.
        let csRankingsData = null;       // from generated-author-info.csv
        let areaPublicationsData = null; // from area_publications.csv

        // Global mappings built from conferences.csv.
        // Maps a conference code (e.g., "aaai") to its aggregated area information.
        const conferenceMapping = {};
        // Maps an aggregated area code (e.g., "ai") to its title and parent.
        const areaMapping = {};
        // List of parent areas in the order they should be displayed.
        const parentAreas = ["AI", "Systems", "Theory", "Interdisciplinary Areas"];
        const parentAreaFill = {
            "AI": 'rgba(55, 126, 184, 0.2)',
            "Systems": 'rgba(255, 127, 0, 0.2)',
            "Theory": 'rgba(75, 175, 74, 0.2)',
            "Interdisciplinary Areas": 'rgba(152, 78, 163, 0.2)'
        };
        const parentAreaBorder = {
            "AI": 'rgba(55, 126, 184, 1.0)',
            "Systems": 'rgba(255, 127, 0, 1.0)',
            "Theory": 'rgba(75, 175, 74, 1.0)',
            "Interdisciplinary Areas": 'rgba(152, 78, 163, 1.0)'
        };

        // Populate date range selectors from 1970 to 2100.
        function populateDateSelectors() {
            const fromSelect = document.getElementById('from-date');
            const toSelect = document.getElementById('to-date');
            for (let year = 1970; year <= 2100; year++) {
                const optionFrom = document.createElement('option');
                optionFrom.value = year;
                optionFrom.text = year;
                fromSelect.appendChild(optionFrom);

                const optionTo = document.createElement('option');
                optionTo.value = year;
                optionTo.text = year;
                toSelect.appendChild(optionTo);
            }
            fromSelect.value = 2019;
            toSelect.value = 2023;
        }

        // Build the conference checkbox tree from local conferences.csv.
        // Also builds the global conferenceMapping and areaMapping.
        function buildConferenceCheckboxes() {
            return fetch('./conferences.csv')
                .then(response => response.text())
                .then(text => {
                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    const rows = lines.slice(1); // skip header

                    // Parse rows into conference objects.
                    const conferences = rows.map(row => {
                        const cols = row.split(',');
                        return {
                            Conference: cols[0].trim(),       // e.g. "aaai"
                            ConferenceTitle: cols[1].trim(),    // e.g. "AAAI"
                            Area: cols[2].trim(),               // aggregated area code, e.g. "ai"
                            AreaTitle: cols[3].trim(),          // e.g. "Artificial intelligence"
                            ParentArea: cols[4].trim(),         // e.g. "AI"
                            NextTier: cols[5].trim().toLowerCase() // "true" or "false"
                        };
                    });

                    // Group conferences by ParentArea then by Area.
                    const grouped = {};
                    conferences.forEach(conf => {
                        if (!grouped[conf.ParentArea]) {
                            grouped[conf.ParentArea] = {};
                        }
                        if (!grouped[conf.ParentArea][conf.Area]) {
                            grouped[conf.ParentArea][conf.Area] = {
                                areaTitle: conf.AreaTitle,
                                conferences: []
                            };
                            // Build areaMapping.
                            areaMapping[conf.Area] = { areaTitle: conf.AreaTitle, parent: conf.ParentArea };
                        }
                        grouped[conf.ParentArea][conf.Area].conferences.push(conf);
                        // Build conferenceMapping.
                        conferenceMapping[conf.Conference] = {
                            area: conf.Area,
                            areaTitle: conf.AreaTitle,
                            parent: conf.ParentArea,
                            nextTier: conf.NextTier,
                            title: conf.ConferenceTitle
                        };
                    });

                    const container = document.getElementById('checkboxes');
                    container.innerHTML = ''; // clear previous content

                    // Iterate over parent areas.
                    // Sort by alphabetical: Object.keys(grouped).sort()
                    parentAreas.forEach(parent => {
                        const parentDiv = document.createElement('div');
                        parentDiv.classList.add('parent-area');

                        const parentCheckbox = document.createElement('input');
                        parentCheckbox.type = 'checkbox';
                        parentCheckbox.id = 'parent-' + parent;
                        parentCheckbox.classList.add('parent-checkbox');
                        parentCheckbox.checked = true;
                        parentCheckbox.disabled = false;

                        const parentLabel = document.createElement('label');
                        parentLabel.htmlFor = parentCheckbox.id;
                        parentLabel.innerText = parent;

                        parentDiv.appendChild(parentCheckbox);
                        parentDiv.appendChild(parentLabel);

                        // Container for areas under this parent.
                        const areaContainer = document.createElement('div');
                        areaContainer.classList.add('area-container');

                        Object.keys(grouped[parent]).sort((a, b) => {
                            let aTitle = grouped[parent][a].areaTitle.toLowerCase();
                            let bTitle = grouped[parent][b].areaTitle.toLowerCase();
                            return aTitle.localeCompare(bTitle);
                        }).forEach(area => {
                            const areaObj = grouped[parent][area];
                            const areaDiv = document.createElement('div');
                            areaDiv.classList.add('area');

                            const areaCheckbox = document.createElement('input');
                            areaCheckbox.type = 'checkbox';
                            areaCheckbox.id = 'area-' + area;
                            areaCheckbox.classList.add('area-checkbox');
                            areaCheckbox.checked = true;
                            areaCheckbox.disabled = false;

                            const areaLabel = document.createElement('label');
                            areaLabel.htmlFor = areaCheckbox.id;
                            areaLabel.innerText = areaObj.areaTitle;

                            areaDiv.appendChild(areaCheckbox);
                            areaDiv.appendChild(areaLabel);

                            // Container for conferences within this area.
                            const confContainer = document.createElement('div');
                            confContainer.classList.add('conference-container');

                            // Split into first-tier and next-tier conferences.
                            const firstTierConfs = areaObj.conferences.filter(conf => conf.NextTier !== 'true');
                            const nextTierConfs = areaObj.conferences.filter(conf => conf.NextTier === 'true');

                            // Render first-tier conferences (preselected).
                            firstTierConfs.forEach(conf => {
                                const confDiv = document.createElement('div');
                                confDiv.classList.add('conference');

                                const confCheckbox = document.createElement('input');
                                confCheckbox.type = 'checkbox';
                                confCheckbox.id = 'conf-' + conf.Conference;
                                confCheckbox.classList.add('conference-checkbox');
                                confCheckbox.value = conf.Conference;
                                confCheckbox.checked = true;
                                confCheckbox.disabled = conf.Conference === "iclr";
                                confCheckbox.dataset.nexttier = conf.NextTier;

                                const confLabel = document.createElement('label');
                                confLabel.htmlFor = confCheckbox.id;
                                confLabel.innerText = conf.ConferenceTitle;

                                confDiv.appendChild(confCheckbox);
                                confDiv.appendChild(confLabel);
                                confContainer.appendChild(confDiv);
                            });

                            // Render next-tier conferences (unselected) with a separator.
                            if (nextTierConfs.length > 0) {
                                const sep = document.createElement('div');
                                sep.classList.add('separator');
                                confContainer.appendChild(sep);

                                nextTierConfs.forEach(conf => {
                                    const confDiv = document.createElement('div');
                                    confDiv.classList.add('conference');

                                    const confCheckbox = document.createElement('input');
                                    confCheckbox.type = 'checkbox';
                                    confCheckbox.id = 'conf-' + conf.Conference;
                                    confCheckbox.classList.add('conference-checkbox');
                                    confCheckbox.value = conf.Conference;
                                    confCheckbox.checked = false;
                                    confCheckbox.dataset.nexttier = conf.NextTier;

                                    const confLabel = document.createElement('label');
                                    confLabel.htmlFor = confCheckbox.id;
                                    confLabel.innerText = conf.ConferenceTitle;

                                    confDiv.appendChild(confCheckbox);
                                    confDiv.appendChild(confLabel);
                                    confContainer.appendChild(confDiv);
                                });
                            }

                            // When an area checkbox is toggled, update only its first-tier conference checkboxes.
                            areaCheckbox.addEventListener('change', function () {
                                const confCheckboxes = confContainer.querySelectorAll('input[type="checkbox"]');
                                confCheckboxes.forEach(cb => {
                                    if (cb.dataset.nexttier !== 'true' && !cb.disabled) {
                                        cb.checked = areaCheckbox.checked;
                                    }
                                });
                                updateResults();
                            });

                            areaDiv.appendChild(confContainer);
                            areaContainer.appendChild(areaDiv);
                        });
                        parentDiv.appendChild(areaContainer);

                        // Parent checkbox toggles all areas.
                        parentCheckbox.addEventListener('change', function () {
                            const areaCheckboxes = parentDiv.querySelectorAll('.area-checkbox');
                            areaCheckboxes.forEach(areaCb => {
                                areaCb.checked = parentCheckbox.checked;
                                areaCb.dispatchEvent(new Event('change'));
                            });
                            updateResults();
                        });

                        container.appendChild(parentDiv);
                    });
                });
        }

        // Update results: compute effective faculties and publication counts,
        // and output the results in a hierarchical, alphabetically sorted structure.
        function updateResults() {
            const canvas = document.getElementById('canvas');
            if (!csRankingsData || !areaPublicationsData) {
                return; // Wait until both datasets are loaded.
            }

            // Get the user-selected date range and compute number of years.
            const fromYear = parseInt(document.getElementById('from-date').value);
            const toYear = parseInt(document.getElementById('to-date').value);
            const userYears = toYear - fromYear + 1;

            // Get selected conference codes from the sidebar checkboxes.
            const selectedConfCheckboxes = document.querySelectorAll('.conference-checkbox:checked');
            const selectedConfs = new Set(Array.from(selectedConfCheckboxes).map(cb => cb.value));

            /* 1. Effective Faculties Calculation (for user-selected range)
               For each faculty, build the set of areas (from any publication in a selected conference)
               and count them fractionally.
            */
            /* 1. Effective Faculties: split across ALL conferences (not just selected).
               This makes per-conference ICLR points stable regardless of selection.
            */
            // Build faculty → { confCode: paperCount } using ALL known conferences
            const facultyMap = {};
            csRankingsData.forEach(row => {
                const name = row[0].trim();
                const confCode = row[2].trim();
                const year = parseInt(row[5].trim());
                if (year >= fromYear && year <= toYear && conferenceMapping[confCode]) {
                    if (!facultyMap[name]) facultyMap[name] = {};
                    facultyMap[name][confCode] = (facultyMap[name][confCode] || 0) + 1;
                }
            });

            // Compute effective faculties per conference (stable, selection-independent)
            const confEffective = {};
            for (const faculty in facultyMap) {
                const confs = facultyMap[faculty];
                const totalPapers = Object.values(confs).reduce((a, b) => a + b, 0);
                for (const conf in confs) {
                    const weight = confs[conf] / totalPapers;
                    confEffective[conf] = (confEffective[conf] || 0) + weight;
                }
            }

            /* 2. Publication counts per conference (stable, selection-independent) */
            const confPublications = {};
            areaPublicationsData.forEach(row => {
                const confCode = row[0].trim();
                const year = parseInt(row[1].trim());
                const pubCount = parseFloat(row[2].trim());
                if (year >= fromYear && year <= toYear && conferenceMapping[confCode]) {
                    confPublications[confCode] = (confPublications[confCode] || 0) + pubCount;
                }
            });

            /* 3. Per-conference effort and ICLR points (stable) */
            const confEffort = {};
            for (const conf in confEffective) {
                const pubs = confPublications[conf] || 0;
                confEffort[conf] = pubs > 0 ? (confEffective[conf] * userYears) / pubs : 0;
            }

            // ICLR baseline (always stable)
            const mlEffortUnit = confEffort["iclr"] || 0;

            const confEffortICLR = {};
            for (const conf in confEffort) {
                confEffortICLR[conf] = mlEffortUnit > 0 ? confEffort[conf] / mlEffortUnit : 0;
            }

            /* 4. Area-level aggregation from SELECTED conferences only */
            const areaEffective = {};
            const areaPublications = {};
            for (const conf of selectedConfs) {
                if (confEffective[conf]) {
                    const areaCode = conferenceMapping[conf].area;
                    areaEffective[areaCode] = (areaEffective[areaCode] || 0) + confEffective[conf];
                }
                if (confPublications[conf]) {
                    const areaCode = conferenceMapping[conf].area;
                    areaPublications[areaCode] = (areaPublications[areaCode] || 0) + confPublications[conf];
                }
            }

            const areaEffort = {};
            for (const area in areaEffective) {
                const pubs = areaPublications[area] || 0;
                areaEffort[area] = pubs > 0 ? (areaEffective[area] * userYears) / pubs : 0;
            }

            const areaEffortICLR = {};
            for (const area in areaEffort) {
                areaEffortICLR[area] = mlEffortUnit > 0 ? areaEffort[area] / mlEffortUnit : 0;
            }

            const parentEffective = {};
            for (const area in areaEffective) {
                if (areaMapping[area]) {
                    const parent = areaMapping[area].parent;
                    parentEffective[parent] = (parentEffective[parent] || 0) + areaEffective[area];
                }
            }
            const parentPublications = {};
            for (const area in areaPublications) {
                if (areaMapping[area]) {
                    const parent = areaMapping[area].parent;
                    parentPublications[parent] = (parentPublications[parent] || 0) + areaPublications[area];
                }
            }
            const parentEffort = {};
            for (const parent in parentEffective) {
                const pubs = parentPublications[parent] || 0;
                parentEffort[parent] = pubs > 0 ? (parentEffective[parent] * userYears) / pubs : 0;
            }
            const parentEffortICLR = {};
            for (const parent in parentEffort) {
                parentEffortICLR[parent] = mlEffortUnit > 0 ? parentEffort[parent] / mlEffortUnit : 0;
            }

            /* 6. Build Hierarchical, Sorted Output.
               For each parent area (alphabetically), list its effective faculty count, publication count,
               average effort (per year), and effort in ICLR points.
            */
            // const parentKeys = new Set([...Object.keys(parentEffective), ...Object.keys(parentPublications)]);

            // let html = '<h2>Results</h2>';
            // parentAreas.forEach(parent => {
            //     const parentEffCount = parentEffective[parent] ? parentEffective[parent].toFixed(2) : '0.00';
            //     const parentPubs = parentPublications[parent] ? parentPublications[parent].toFixed(0) : '0';
            //     const parentEffVal = parentEffort[parent] ? parentEffort[parent].toFixed(2) : '0.00';
            //     const parentICLR = parentEffortICLR[parent] ? parentEffortICLR[parent].toFixed(2) : '0.00';
            //     html += `<h3>${parent} (Effective Faculties: ${parentEffCount}, Publications: ${parentPubs}, Effort: ${parentEffVal} per faculty-year, ${parentICLR} ICLR points)</h3>`;

            //     // Get all areas (from areaMapping) for this parent, sorted alphabetically by area title.
            //     const areasForParent = Object.keys(areaMapping)
            //         .filter(area => areaMapping[area].parent === parent)
            //         .sort((a, b) => {
            //             const aTitle = areaMapping[a].areaTitle.toLowerCase();
            //             const bTitle = areaMapping[b].areaTitle.toLowerCase();
            //             return aTitle.localeCompare(bTitle);
            //         });
            //     html += '<ul>';
            //     areasForParent.forEach(area => {
            //         const areaTitle = areaMapping[area].areaTitle;
            //         const eff = areaEffective[area] ? areaEffective[area].toFixed(2) : '0.00';
            //         const pubs = areaPublications[area] ? areaPublications[area].toFixed(0) : '0';
            //         const effortVal = areaEffort[area] ? areaEffort[area].toFixed(2) : '0.00';
            //         const iclrPoints = areaEffortICLR[area] ? areaEffortICLR[area].toFixed(2) : '0.00';
            //         html += `<li>${areaTitle} (${area}): Effective Faculties: ${eff}, Publications: ${pubs}, Effort: ${effortVal} per year, ${iclrPoints} ICLR points</li>`;
            //     });
            //     html += '</ul>';
            // });

            // document.getElementById('results').innerHTML = html;
            document.getElementById('results').innerHTML = "";

            // Determine which view is active
            const viewMode = document.querySelector('input[name="view"]:checked').value;

            // Prepare chart data
            const labels = [];
            const iclrPointsData = [];
            const fillColor = [];
            const borderColor = [];

            if (viewMode === 'area') {
                // Area view: one bar per area, grouped by parent
                parentAreas.forEach(parent => {
                    const areasForParent = Object.keys(areaMapping)
                        .filter(area => areaMapping[area].parent === parent)
                        .sort((a, b) => {
                            const aTitle = areaMapping[a].areaTitle.toLowerCase();
                            const bTitle = areaMapping[b].areaTitle.toLowerCase();
                            return aTitle.localeCompare(bTitle);
                        });
                    areasForParent.forEach(area => {
                        if (areaEffortICLR.hasOwnProperty(area)) {
                            labels.push(areaMapping[area].areaTitle);
                            iclrPointsData.push(parseFloat(areaEffortICLR[area].toFixed(2)));
                            fillColor.push(parentAreaFill[parent]);
                            borderColor.push(parentAreaBorder[parent]);
                        }
                    });
                });
            } else {
                // Conference view: grouped by parent → area → conference (matching sidebar order)
                parentAreas.forEach(parent => {
                    const areasForParent = Object.keys(areaMapping)
                        .filter(area => areaMapping[area].parent === parent)
                        .sort((a, b) => {
                            const aTitle = areaMapping[a].areaTitle.toLowerCase();
                            const bTitle = areaMapping[b].areaTitle.toLowerCase();
                            return aTitle.localeCompare(bTitle);
                        });
                    areasForParent.forEach(area => {
                        const confsForArea = Object.keys(confEffortICLR)
                            .filter(conf => selectedConfs.has(conf) && conferenceMapping[conf] && conferenceMapping[conf].area === area)
                            .sort((a, b) => {
                                const aTitle = (conferenceMapping[a].title || a).toLowerCase();
                                const bTitle = (conferenceMapping[b].title || b).toLowerCase();
                                return aTitle.localeCompare(bTitle);
                            });
                        confsForArea.forEach(conf => {
                            labels.push(conferenceMapping[conf].title || conf.toUpperCase());
                            iclrPointsData.push(parseFloat(confEffortICLR[conf].toFixed(2)));
                            fillColor.push(parentAreaFill[parent]);
                            borderColor.push(parentAreaBorder[parent]);
                        });
                    });
                });
            }

            // Destroy previous chart, set canvas height, then recreate
            if (window.iclrChart instanceof Chart) {
                window.iclrChart.destroy();
                window.iclrChart = null;
            }

            const chartCanvas = document.getElementById('iclrChart');
            chartCanvas.setAttribute('height', Math.max(400, labels.length * 20));

            if (!window._chartPluginRegistered) {
                Chart.register(ChartDataLabels);
                window._chartPluginRegistered = true;
            }

            const ctx = chartCanvas.getContext('2d');
            window.iclrChart = new Chart(ctx, {
                plugins: [ChartDataLabels],
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'ICLR point',
                        data: iclrPointsData,
                        backgroundColor: fillColor,
                        borderColor: borderColor,
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    scales: {
                        x: {
                            beginAtZero: true
                        },
                        y: {
                            ticks: {
                                display: true,
                                autoSkip: false
                            }
                        }
                    },
                    plugins: {
                        datalabels: {
                            anchor: 'start',
                            align: 'end',
                            formatter: (value, context) => {
                                return value.toFixed(2);
                            }
                        }
                    }
                }
            });
        }

        // Load generated-author-info.csv (local copy).
        function loadCSRankingsData() {
            return fetch('./generated-author-info.csv')
                .then(response => response.text())
                .then(text => {
                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    csRankingsData = lines.slice(1).map(line => line.replace(/"/g, '').split(','));
                });
        }

        // Load area_publications.csv.
        function loadAreaPublicationsData() {
            return fetch('./area_publications.csv')
                .then(response => response.text())
                .then(text => {
                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    areaPublicationsData = lines.slice(1).map(line => line.replace(/"/g, '').split(','));
                });
        }

        // Attach change event listeners so that updates occur on any selection change.
        function attachSelectionListeners() {
            document.getElementById('from-date').addEventListener('change', updateResults);
            document.getElementById('to-date').addEventListener('change', updateResults);
            document.getElementById('sidebar').addEventListener('change', function (e) {
                if (e.target && e.target.matches('input[type="checkbox"]')) {
                    updateResults();
                }
            });
            document.querySelectorAll('input[name="view"]').forEach(radio => {
                radio.addEventListener('change', updateResults);
            });
        }

        document.addEventListener('DOMContentLoaded', function () {
            populateDateSelectors();
            buildConferenceCheckboxes().then(() => {
                attachSelectionListeners();
                Promise.all([loadCSRankingsData(), loadAreaPublicationsData()]).then(() => {
                    updateResults();
                });
            });
        });
    </script>

    <footer>
        The edits to this fork have been mostly vibe coded using <a href="https://claude.ai/">Claude</a>.
    </footer>

</body>

</html>
